<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pidgin</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #fafafa;
      color: #222;
      height: 100vh;
      overflow: hidden;
    }

    .layout {
      display: grid;
      grid-template-columns: 260px 1fr;
      height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      background: #fff;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      padding: 1.5rem 1rem 1rem;
      border-bottom: 1px solid #e0e0e0;
    }

    .sidebar-header h1 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .sidebar-header .corpus-label {
      font-size: 0.75rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .sidebar-tabs {
      display: flex;
      border-bottom: 1px solid #e0e0e0;
    }

    .sidebar-tab {
      flex: 1;
      padding: 0.75rem 0.5rem;
      background: none;
      border: none;
      font-size: 0.75rem;
      font-weight: 500;
      color: #666;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
    }

    .sidebar-tab:hover {
      color: #222;
    }

    .sidebar-tab.active {
      color: #1976d2;
      border-bottom-color: #1976d2;
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }

    .conversation-item {
      padding: 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 2px;
      transition: background 0.1s;
    }

    .conversation-item:hover {
      background: #f5f5f5;
    }

    .conversation-item.active {
      background: #e3f2fd;
    }

    .conversation-item .title {
      font-size: 0.9rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .conversation-item .meta {
      font-size: 0.75rem;
      color: #888;
    }

    /* Atoms */
    .atom-item {
      padding: 0.6rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 4px;
      transition: background 0.1s;
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
    }

    .atom-item:hover {
      background: #f5f5f5;
    }

    .atom-item.active {
      background: #fff3e0;
    }

    .atom-item .term {
      font-size: 0.95rem;
      font-weight: 600;
      color: #e65100;
    }

    .atom-item .count {
      font-size: 0.7rem;
      color: #888;
    }

    .atom-item .source {
      font-size: 0.7rem;
      color: #888;
      margin-left: auto;
    }

    .atoms-header {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: #888;
      padding: 0.75rem 0.75rem 0.5rem;
    }

    .sidebar-footer {
      padding: 1rem;
      border-top: 1px solid #e0e0e0;
      font-size: 0.75rem;
      color: #888;
    }

    /* Main reader */
    .reader {
      overflow-y: auto;
      padding: 2rem 3rem;
    }

    .reader-inner {
      max-width: 700px;
    }

    .reader-header {
      margin-bottom: 2rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid #e0e0e0;
    }

    .reader-header h1 {
      font-size: 1.75rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
    }

    .reader-meta {
      display: flex;
      gap: 1.5rem;
      font-size: 0.85rem;
      color: #666;
    }

    .reader-meta span {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    /* Conversation turns */
    .turn {
      margin-bottom: 2.5rem;
    }

    .turn-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .turn-role {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      flex-shrink: 0;
    }

    .turn-role .icon {
      width: 14px;
      height: 14px;
    }

    .turn-role.user { color: #1976d2; }
    .turn-role.assistant { color: #7b1fa2; }

    .turn-rule {
      flex: 1;
      height: 1px;
    }

    .turn.user-turn .turn-rule {
      background: linear-gradient(to right, #1976d2, transparent);
    }

    .turn.assistant-turn .turn-rule {
      background: linear-gradient(to right, #7b1fa2, transparent);
    }

    .turn-content {
      font-size: 1rem;
      line-height: 1.7;
    }

    /* Markdown styling */
    .turn-content p { margin-bottom: 1rem; }
    .turn-content p:last-child { margin-bottom: 0; }

    .turn-content h1, .turn-content h2, .turn-content h3 {
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }

    .turn-content h1 { font-size: 1.4rem; }
    .turn-content h2 { font-size: 1.2rem; }
    .turn-content h3 { font-size: 1.1rem; }

    .turn-content strong { font-weight: 600; }
    .turn-content em { font-style: italic; }

    .turn-content ul, .turn-content ol {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
    }

    .turn-content li { margin-bottom: 0.35rem; }

    .turn-content code {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 0.9em;
      background: #f5f5f5;
      padding: 0.15em 0.4em;
      border-radius: 3px;
    }

    .turn-content pre {
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 1rem;
      border-radius: 6px;
      overflow-x: auto;
      margin-bottom: 1rem;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .turn-content pre code {
      background: none;
      padding: 0;
      color: inherit;
    }

    .turn-content blockquote {
      border-left: 3px solid #ddd;
      padding-left: 1rem;
      color: #666;
      margin-bottom: 1rem;
    }

    .turn-content table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
      font-size: 0.9rem;
    }

    .turn-content th, .turn-content td {
      border: 1px solid #ddd;
      padding: 0.5rem 0.75rem;
      text-align: left;
    }

    .turn-content th {
      background: #f5f5f5;
      font-weight: 600;
    }

    .turn-content hr {
      border: none;
      border-top: 1px solid #e0e0e0;
      margin: 1.5rem 0;
    }

    /* Atom highlights in text */
    .atom-highlight {
      background: linear-gradient(to bottom, transparent 60%, rgba(255, 167, 38, 0.3) 60%);
      cursor: pointer;
      transition: background 0.15s;
    }

    .atom-highlight:hover {
      background: rgba(255, 167, 38, 0.4);
    }

    /* Turn interaction */
    .turn[data-turn] {
      padding: 1rem;
      margin-left: -1rem;
      margin-right: -1rem;
      border-radius: 8px;
      transition: background 0.15s;
    }

    .turn[data-turn].highlighted {
      background: #fff8e1;
    }

    /* Occurrence cards in main view */
    .occurrence-card {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 1.25rem;
      margin-bottom: 1rem;
      cursor: pointer;
      transition: border-color 0.15s, box-shadow 0.15s;
    }

    .occurrence-card:hover {
      border-color: #bbb;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .occurrence-card .source {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .occurrence-card .source .role-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      flex-shrink: 0;
    }

    .occurrence-card .source .role-icon.user {
      color: #1976d2;
      background: #e3f2fd;
    }

    .occurrence-card .source .role-icon.assistant {
      color: #7b1fa2;
      background: #f3e5f5;
    }

    .occurrence-card .source .role-icon .icon {
      width: 16px;
      height: 16px;
    }

    .occurrence-card .source .conv-title {
      flex: 1;
    }

    .occurrence-card .source .scale-label {
      color: #aaa;
      font-size: 0.7rem;
    }

    .occurrence-card .text {
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .occurrence-card .text p {
      margin: 0 0 0.75rem 0;
    }

    .occurrence-card .text p:last-child {
      margin-bottom: 0;
    }

    .occurrence-card .text code {
      font-size: 0.85em;
      background: #f5f5f5;
      padding: 0.15em 0.4em;
      border-radius: 3px;
    }

    .occurrence-card .text pre {
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 0.75rem;
      border-radius: 6px;
      overflow-x: auto;
      margin: 0.5rem 0;
      font-size: 0.8rem;
    }

    .occurrence-card .text pre code {
      background: none;
      padding: 0;
      color: inherit;
    }

    .occurrence-card .text ul, .occurrence-card .text ol {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }

    .occurrence-card .text strong {
      font-weight: 600;
    }

    .occurrence-card .text blockquote {
      border-left: 3px solid #ddd;
      padding-left: 1rem;
      color: #666;
      margin: 0.5rem 0;
    }

    /* Empty state */
    .empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #888;
      font-size: 0.9rem;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
      .sidebar { display: none; }
      .reader { padding: 1.5rem; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>Pidgin</h1>
        <div class="corpus-label">corpus</div>
      </div>
      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-tab="conversations">Conversations</button>
        <button class="sidebar-tab" data-tab="atoms">Atoms</button>
      </div>
      <div class="sidebar-content" id="sidebar-content"></div>
      <div class="sidebar-footer" id="sidebar-footer">Loading...</div>
    </aside>

    <main class="reader" id="reader">
      <div class="empty-state">Select a conversation</div>
    </main>
  </div>



  <script type="module">
    marked.setOptions({ gfm: true, breaks: true });

    // Icons for user/assistant
    const icons = {
      user: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/>
      </svg>`,
      assistant: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/>
      </svg>`
    };

    const state = {
      conversations: [],
      chunks: [],
      embeddings: [],
      atoms: [],
      atomOccurrences: new Map(), // atom term -> [chunk indices]
      currentConversation: null,
      currentTab: 'conversations',
      currentAtom: null,
      ready: false,
      worker: null
    };

    const els = {
      sidebarContent: document.getElementById('sidebar-content'),
      sidebarFooter: document.getElementById('sidebar-footer'),
      reader: document.getElementById('reader')
    };

    // Highlight atoms in HTML content
    function highlightAtoms(html) {
      let result = html;

      for (const atom of state.atoms) {
        const terms = [atom.term, ...(atom.aliases || [])];

        for (const term of terms) {
          // Match whole words, case insensitive, but preserve original case
          const regex = new RegExp(`\\b(${term})\\b`, 'gi');
          result = result.replace(regex, `<span class="atom-highlight" data-atom="${atom.term}">$1</span>`);
        }
      }

      return result;
    }

    function truncate(text, max = 150) {
      if (text.length <= max) return text;
      return text.slice(0, max).trim() + '...';
    }

    // Render sidebar based on current tab
    function renderSidebar() {
      document.querySelectorAll('.sidebar-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === state.currentTab);
      });

      if (state.currentTab === 'conversations') {
        renderConversationList();
      } else {
        renderAtomsList();
      }
    }

    function renderConversationList() {
      els.sidebarContent.innerHTML = state.conversations.map((conv, i) => `
        <div class="conversation-item${state.currentConversation === i ? ' active' : ''}" data-index="${i}">
          <div class="title">${conv.title}</div>
          <div class="meta">${conv.frontmatter.date || ''} · ${conv.turns.length} turns</div>
        </div>
      `).join('');

      els.sidebarContent.querySelectorAll('.conversation-item').forEach(el => {
        el.addEventListener('click', () => selectConversation(parseInt(el.dataset.index)));
      });
    }

    function renderAtomsList() {
      if (state.atoms.length === 0) {
        els.sidebarContent.innerHTML = '<div class="empty-state">No atoms defined</div>';
        return;
      }

      // Sort by occurrence count
      const sorted = [...state.atoms].sort((a, b) => {
        const countA = state.atomOccurrences.get(a.term)?.length || 0;
        const countB = state.atomOccurrences.get(b.term)?.length || 0;
        return countB - countA;
      });

      els.sidebarContent.innerHTML = `
        <div class="atoms-header">Named concepts</div>
        ${sorted.map(atom => {
          const count = state.atomOccurrences.get(atom.term)?.length || 0;
          return `
            <div class="atom-item${state.currentAtom === atom.term ? ' active' : ''}" data-term="${atom.term}">
              <span class="term">${atom.term}</span>
              <span class="count">${count} passages</span>
            </div>
          `;
        }).join('')}
      `;

      els.sidebarContent.querySelectorAll('.atom-item').forEach(el => {
        el.addEventListener('click', () => {
          const term = el.dataset.term;
          showAtomOccurrences(term);
        });
      });
    }

    function renderReader(conv) {
      const metaParts = [];
      if (conv.frontmatter.date) metaParts.push(`<span>${conv.frontmatter.date}</span>`);
      if (conv.frontmatter.follows) metaParts.push(`<span>follows: ${conv.frontmatter.follows}</span>`);

      const turnsHtml = conv.turns.map((turn, i) => {
        const rendered = marked.parse(turn.text);
        const highlighted = highlightAtoms(rendered);
        const icon = turn.role === 'user' ? icons.user : icons.assistant;
        const turnClass = turn.role === 'user' ? 'user-turn' : 'assistant-turn';
        return `
          <div class="turn ${turnClass}" data-turn="${i}">
            <div class="turn-header">
              <div class="turn-role ${turn.role}">${icon}${turn.role}</div>
              <div class="turn-rule"></div>
            </div>
            <div class="turn-content">${highlighted}</div>
          </div>
        `;
      }).join('');

      els.reader.innerHTML = `
        <div class="reader-inner">
          <header class="reader-header">
            <h1>${conv.title}</h1>
            ${metaParts.length ? `<div class="reader-meta">${metaParts.join('')}</div>` : ''}
          </header>
          <article class="turns">${turnsHtml}</article>
        </div>
      `;

      // Click on atom highlight to see occurrences
      els.reader.querySelectorAll('.atom-highlight').forEach(el => {
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          const term = el.dataset.atom;
          showAtomOccurrences(term);
        });
      });

    }

    function selectConversation(index) {
      state.currentConversation = index;
      state.currentAtom = null;
      renderSidebar();
      renderReader(state.conversations[index]);
    }

    function showAtomOccurrences(term) {
      state.currentAtom = term;
      state.currentConversation = null;
      renderSidebar();

      const atom = state.atoms.find(a => a.term === term);
      const indices = state.atomOccurrences.get(term) || [];

      const cardsHtml = indices.length === 0
        ? '<div class="empty-state">No occurrences found</div>'
        : indices.map(index => {
            const chunk = state.chunks[index];
            const convTitle = state.conversations.find(c => c.filename === chunk.source)?.title || chunk.source;
            const rendered = highlightAtoms(marked.parse(chunk.text));
            const scaleLabel = chunk.scale === 'paragraph' ? 'paragraph' : 'turn';
            const icon = chunk.role === 'user' ? icons.user : icons.assistant;
            return `
              <div class="occurrence-card" data-source="${chunk.source}" data-turn-index="${chunk.turnIndex}">
                <div class="source">
                  <span class="role-icon ${chunk.role}">${icon}</span>
                  <span class="conv-title">${convTitle}</span>
                  <span class="scale-label">${scaleLabel}</span>
                </div>
                <div class="text">${rendered}</div>
              </div>
            `;
          }).join('');

      els.reader.innerHTML = `
        <div class="reader-inner">
          <header class="reader-header">
            <h1>${term}</h1>
            <div class="reader-meta">
              <span>${indices.length} occurrence${indices.length !== 1 ? 's' : ''}</span>
              ${atom?.source ? `<span>named in: ${atom.source.replace('.md', '').replace(/-/g, ' ')}</span>` : ''}
            </div>
          </header>
          <div class="occurrences">${cardsHtml}</div>
        </div>
      `;

      els.reader.querySelectorAll('.occurrence-card').forEach(el => {
        el.addEventListener('click', () => {
          const source = el.dataset.source;
          const turnIndex = parseInt(el.dataset.turnIndex);
          const convIndex = state.conversations.findIndex(c => c.filename === source);
          if (convIndex >= 0) {
            selectConversation(convIndex);
            setTimeout(() => {
              const targetEl = els.reader.querySelector(`.turn[data-turn="${turnIndex}"]`);
              if (targetEl) {
                targetEl.classList.add('highlighted');
                targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }
            }, 50);
          }
        });
      });
    }


    // Setup
    function setupEventListeners() {
      document.querySelectorAll('.sidebar-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          state.currentTab = tab.dataset.tab;
          state.currentAtom = null;
          renderSidebar();
        });
      });
    }

    function updateFooter(status = '') {
      const suffix = status ? ` · ${status}` : (state.ready ? '' : ' · indexing...');
      const turnCount = state.chunks.filter(c => c.scale === 'turn').length;
      const paraCount = state.chunks.filter(c => c.scale === 'paragraph').length;
      els.sidebarFooter.textContent = `${turnCount} turns · ${paraCount} paragraphs · ${state.atoms.length} atoms${suffix}`;
    }

    // Load embeddings in a web worker (non-blocking)
    function loadEmbeddingsInWorker() {
      try {
        state.worker = new Worker('embedding-worker.js', { type: 'module' });

        state.worker.onmessage = (e) => {
          const { type, embeddings, current, total, message } = e.data;

          if (type === 'progress') {
            updateFooter(`${current}/${total}`);
          } else if (type === 'complete') {
            state.embeddings = embeddings;
            state.ready = true;
            updateFooter();
            state.worker.terminate();
            state.worker = null;
          } else if (type === 'error') {
            console.error('Worker error:', message);
            updateFooter('index failed');
          }
        };

        state.worker.onerror = (e) => {
          console.error('Worker error:', e);
          updateFooter('index failed');
        };

        // Send chunks to worker
        const texts = state.chunks.map(c => c.text);
        state.worker.postMessage({ type: 'embed', chunks: texts });
      } catch (error) {
        console.error('Failed to start worker:', error);
        updateFooter('');
      }
    }

    async function main() {
      try {
        // Load pre-computed index
        const indexRes = await fetch('dist/index.json');
        if (!indexRes.ok) {
          throw new Error('Could not load index. Run: npm run build');
        }
        const index = await indexRes.json();

        // Populate state from index
        state.atoms = index.terms;
        state.conversations = index.conversations;
        state.chunks = index.chunks;
        state.embeddings = index.embeddings || [];
        state.ready = state.embeddings.length > 0;

        // Convert occurrences object to Map
        for (const [term, indices] of Object.entries(index.occurrences)) {
          state.atomOccurrences.set(term, indices);
        }

        if (state.conversations.length === 0) {
          els.sidebarFooter.textContent = 'No conversations found';
          return;
        }

        // Show UI immediately
        setupEventListeners();
        renderSidebar();
        selectConversation(0);
        updateFooter();

      } catch (error) {
        els.sidebarFooter.textContent = `Error: ${error.message}`;
        console.error(error);
      }
    }

    main();
  </script>
</body>
</html>
